# Error Handling

In Golang, you can handle errors manually with the data type `error` which actually is just a string inside an interface. The default value is `nil`, which means there is no error.

```go
type error interface {
    Error() string
}
```

For example, notice that this `divide` function returns result and error (error is generated by importing Golang package `"errors"`)

```go
func divide(x, y float64) (result float64, err error) {
	if y == 0 {
        err = errors.New("Unable to divide by zero")
        return 0, err
    }
    return float64(x/y), nil
}
```

When dealing with functions like these, here is one way to solve it:

```go
func main() {
	num, err := divide(22, 11)
	if err == nil {
		fmt.Println(num)
	} else {
		fmt.Println(err)
	}
}
```

Here is another way to solve it:

```go
func main() {
	num, err := divide(22, 11)
	if err != nil {
		fmt.Println(err)
	} else {
		fmt.Println(num)
	}
}
```

Notice that the first one puts the checking as "if no error", which is useful when you have a function with varying errors and each requiring different treatment.
The second one puts the checking as "if there is error", which is useful when you have a variable which must survive multiple checks.